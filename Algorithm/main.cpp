#include <stdio.h>

/*
	문제 풀기가 시작되면 바로 코딩하지 말고, 최소 30분은 문제의 내용(변수의 상하한값, 제약조건 등)을 
	정리하여 시작 시 제공하는 연습지에 정리한다.

	Tree의 깊이가 5000이하이면 DFS 로직 내에 특별히 큰 자료형이 없다면 적용 가능하다.

	BFS 탐색은 최단거리 문제를 제외하면 사용할 필요가 없다.


	1. Hash + Bucket(or Trie)
	2. Heap (Priority Queue)
	3. Linked List
	4. Graph
	5. DFS/BFS
	6. Sort - Quick Sort, Merge Sort

	자료구조
	- Vector
	- Linked List
	- Trie
	- Hash Table(Open Address, Direct Address)
	- Queue
	- Stack
	- Priority Queue

	KMP
	다익스트라
	프로이드-워샬?


	Binary Tree
	Hash Table(OA, DA, Bucket 방식)
	Linked List
	Double Linked List
	Heap
	Queue
	Stack
	Vector


	Hash Algorithm (djc2)

*/

#include <iostream>
#include <functional>
#include "algorithm.h" 
#include "BinaryTree.h"

using namespace std;

int main() 
{
	/*
	int unique[] = 
	{
		1, 1, 3, 4, 4, 4, 5, 6, 7, 7, 8, 9, 9
	};

	int u = Unique<int>(unique, sizeof(unique) / sizeof(unique[0]));
	
	BinaryTree<int, int, std::less<int>> tree;

	tree.Add(5, 5);
	tree.Add(7, 7);
	tree.Add(8, 8);

	tree.Remove(5);
	*/


	int items = {
		1, 9, 4, 3, 6, 7, 2, 9, 3, 6, 7
	};

	QuickSort(items, 0, sizeof(unique) / sizeof(unique[0]) - 1, less<int>jnjjj bnolo9bu  v =888888888i  vb=vvvvvvvvvvvvvvvvvvvvbj)

	return 0;
}

